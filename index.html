
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Exploding Models</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #000;
            color: #fff;
            margin: 0px;
            overflow: hidden;
        }
        #info {
            color: #fff;
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display:block;
        }
        #info a, .button { color: #f00; font-weight: bold; text-decoration: underline; cursor: pointer }
    </style>
</head>

<body>

Instances (1-10):
<input type="range" id="instanceSlider" min="1" max="10" value="1">
Tessellation:
<input type="range" id="tessSlider" min="1" max="10" value="1">

<script src="./js/three.js"></script>
<script src="./js/OBJLoader.js"></script>
<script src="./js/BufferSubdivisionModifier.js"></script>


<script id="vertexShader" type="x-shader/x-vertex">
		precision highp float;

		uniform float sineTime;

		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;

		attribute vec3 position;
		attribute vec3 offset;
		attribute vec4 color;

		varying vec3 vPosition;
		varying vec4 vColor;

		void main(){

			vPosition = offset * max(abs(sineTime * 2.0 + 1.0), 0.5) + position;
			vColor = color;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( vPosition, 1.0 );

		}

	</script>

<script id="fragmentShader" type="x-shader/x-fragment">

		precision highp float;

		uniform float time;

		varying vec3 vPosition;
		varying vec4 vColor;

		void main() {

			vec4 color = vec4( vColor );


			gl_FragColor = color;

		}

	</script>


<script>

    var container;

    var camera, scene, renderer;

    var model, parts = [], dirs = [], movementSpeed = 2, colors = [0xFF0FFF, 0xCCFF00, 0xFF000F, 0x996600, 0xFFFFFF];;
    var instances = document.getElementById("instanceSlider").value;
    var subdivisions = document.getElementById("tessSlider").value;
    var loadedObject;
    var needsReset = false;
    var clock = new THREE.Clock(false);

    var windowHalfX = window.innerWidth / 2;
    var windowHalfY = window.innerHeight / 2;


    init();
    animate();


    function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 40 );
        camera.position.z = 10;

        // scene

        scene = new THREE.Scene();

        var ambient = new THREE.AmbientLight( 0x101030 );
        scene.add( ambient );

        var directionalLight = new THREE.DirectionalLight( 0xffeedd );
        directionalLight.position.set( 0, 0, 1 );
        scene.add( directionalLight );

        var manager = new THREE.LoadingManager();
        manager.onProgress = function ( item, loaded, total ) {

            console.log( item, loaded, total );

        };

        var onProgress = function ( xhr ) {
            if ( xhr.lengthComputable ) {
                var percentComplete = xhr.loaded / xhr.total * 100;
                console.log( Math.round(percentComplete, 2) + '% downloaded' );
            }
        };

        var onError = function ( xhr ) {
        };

        // model

        var loader = new THREE.OBJLoader( manager );
        loader.load( 'teapot-lowpoly.obj', function ( object ) {

            loadedObject = object;

            var geometry = new THREE.Geometry().fromBufferGeometry(object.children[0].geometry);
            var modifier = new THREE.BufferSubdivisionModifier( subdivisions );

            geometry = modifier.modify( geometry);
            geometry = new THREE.Geometry().fromBufferGeometry(geometry);
            geometry = new THREE.InstancedBufferGeometry().fromGeometry(geometry);
            geometry.maxInstancedCount = instances;


            var offsets = new THREE.InstancedBufferAttribute( new Float32Array( instances * 22176 ), 3, 1 );

            for ( var i = 0, ul = offsets.count; i < ul; i++ ) {

                offsets.setXYZ( i, Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5 );

            }

            geometry.addAttribute( 'offset', offsets );;

            var colors = new THREE.InstancedBufferAttribute( new Float32Array( instances * 4 ), 4, 1 );

            for ( var i = 0, ul = colors.count; i < ul; i++ ) {

                colors.setXYZW( i, Math.random(), Math.random(), Math.random(), Math.random() );

            }

            geometry.addAttribute( 'color', colors );

            var material = new THREE.RawShaderMaterial( {

                uniforms: {
                    time: { value: 1.0 },
                    sineTime: { value: 1.0 }
                },
                vertexShader: document.getElementById( 'vertexShader' ).textContent,
                fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
                side: THREE.DoubleSide,
                transparent: true,
                wireframe:true

            } );

            model = new THREE.Mesh(geometry, material);


            scene.add( model );

        }, onProgress, onError );

        //

        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );

        var instanceSlider = document.getElementById("instanceSlider");
        instanceSlider.addEventListener("change", function() {
            instances = instanceSlider.value;
            for(var i = scene.children.length - 1; i >= 0; i--){
                var obj = scene.children[i];
                scene.remove(obj);
            }
            var geometry = new THREE.Geometry().fromBufferGeometry(loadedObject.children[0].geometry);
            var modifier = new THREE.BufferSubdivisionModifier( subdivisions );

            geometry = modifier.modify( geometry);
            geometry = new THREE.Geometry().fromBufferGeometry(geometry);
            geometry = new THREE.InstancedBufferGeometry().fromGeometry(geometry);
            geometry.maxInstancedCount = instances;

            var offsets = new THREE.InstancedBufferAttribute( new Float32Array( instances * 22176 ), 3, 1 );

            for ( var i = 0, ul = offsets.count; i < ul; i++ ) {

                offsets.setXYZ( i, Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5 );

            }

            geometry.addAttribute( 'offset', offsets );;

            var colors = new THREE.InstancedBufferAttribute( new Float32Array( instances * 4 ), 4, 1 );

            for ( var i = 0, ul = colors.count; i < ul; i++ ) {

                colors.setXYZW( i, Math.random(), Math.random(), Math.random(), Math.random() );

            }

            geometry.addAttribute( 'color', colors );

            var material = new THREE.RawShaderMaterial( {

                uniforms: {
                    time: { value: 1.0 },
                    sineTime: { value: 1.0 }
                },
                vertexShader: document.getElementById( 'vertexShader' ).textContent,
                fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
                side: THREE.DoubleSide,
                transparent: true,
                wireframe:true

            } );

            model = new THREE.Mesh(geometry, material);


            scene.add( model );

            render();
        });

        var tessSlider = document.getElementById("tessSlider");
        tessSlider.addEventListener("change", function() {
            subdivisions = tessSlider.value;
            for(var i = scene.children.length - 1; i >= 0; i--){
                var obj = scene.children[i];
                scene.remove(obj);
            }
            var geometry = new THREE.Geometry().fromBufferGeometry(loadedObject.children[0].geometry);
            var modifier = new THREE.BufferSubdivisionModifier( subdivisions );

            geometry = modifier.modify( geometry);
            geometry = new THREE.Geometry().fromBufferGeometry(geometry);
            geometry = new THREE.InstancedBufferGeometry().fromGeometry(geometry);
            geometry.maxInstancedCount = instances;

            var offsets = new THREE.InstancedBufferAttribute( new Float32Array( instances * 22176 ), 3, 1 );

            for ( var i = 0, ul = offsets.count; i < ul; i++ ) {

                offsets.setXYZ( i, Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5 );

            }

            geometry.addAttribute( 'offset', offsets );;

            var colors = new THREE.InstancedBufferAttribute( new Float32Array( instances * 4 ), 4, 1 );

            for ( var i = 0, ul = colors.count; i < ul; i++ ) {

                colors.setXYZW( i, Math.random(), Math.random(), Math.random(), Math.random() );

            }

            geometry.addAttribute( 'color', colors );

            var material = new THREE.RawShaderMaterial( {

                uniforms: {
                    time: { value: 1.0 },
                    sineTime: { value: 1.0 }
                },
                vertexShader: document.getElementById( 'vertexShader' ).textContent,
                fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
                side: THREE.DoubleSide,
                transparent: true,
                wireframe: true

            } );

            model = new THREE.Mesh(geometry, material);

            scene.add( model );

            render();
        });

        container.addEventListener( 'mousedown', onclick, false );
        window.addEventListener( 'resize', onWindowResize, false );

    }

    function onclick(){
        //event.preventDefault();
        if (model) {
            model.visible = false;
        }
        parts.push(new ExplodeAnimation(model.geometry));
    }

    function onWindowResize() {

        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    //

    function animate() {

        requestAnimationFrame( animate );

        var pCount = parts.length;
        while(pCount--) {
            parts[pCount].update();
        }

        if (needsReset && !clock.running) {
            clock.start();
        }
        if (clock.getElapsedTime() >= 3) {
            clock.stop();
            clock = new THREE.Clock(false);
            needsReset = false;
            for(var i = scene.children.length - 1; i >= 0; i--){
                var obj = scene.children[i];
                scene.remove(obj);
            }
            var geometry = new THREE.Geometry().fromBufferGeometry(loadedObject.children[0].geometry);
            var modifier = new THREE.BufferSubdivisionModifier( subdivisions );

            geometry = modifier.modify( geometry);
            geometry = new THREE.Geometry().fromBufferGeometry(geometry);
            geometry = new THREE.InstancedBufferGeometry().fromGeometry(geometry);
            geometry.maxInstancedCount = instances;

            var offsets = new THREE.InstancedBufferAttribute( new Float32Array( instances * 22176 ), 3, 1 );

            for ( var i = 0, ul = offsets.count; i < ul; i++ ) {

                offsets.setXYZ( i, Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5 );

            }

            geometry.addAttribute( 'offset', offsets );;

            var colors = new THREE.InstancedBufferAttribute( new Float32Array( instances * 4 ), 4, 1 );

            for ( var i = 0, ul = colors.count; i < ul; i++ ) {

                colors.setXYZW( i, Math.random(), Math.random(), Math.random(), Math.random() );

            }

            geometry.addAttribute( 'color', colors );

            var material = new THREE.RawShaderMaterial( {

                uniforms: {
                    time: { value: 1.0 },
                    sineTime: { value: 1.0 }
                },
                vertexShader: document.getElementById( 'vertexShader' ).textContent,
                fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
                side: THREE.DoubleSide,
                transparent: true,
                wireframe:true

            } );

            model = new THREE.Mesh(geometry, material);


            scene.add( model );
        }

        render();

    }

    function render() {
        camera.lookAt( scene.position );

        renderer.render( scene, camera );

    }

    function ExplodeAnimation(bufferGeometry)
    {
        needsReset = true;
        var geometry = new THREE.Geometry();

        for (var i = 0, len = bufferGeometry.attributes.offset.count; i < len; i ++)
        {
            var vertex = new THREE.Vector3();
            vertex.x = bufferGeometry.attributes.offset.array[3 * i];
            vertex.y = bufferGeometry.attributes.offset.array[3 * i + 1];
            vertex.z = bufferGeometry.attributes.offset.array[3 * i + 2];
            geometry.vertices.push( vertex );

            dirs.push({x:(Math.random() * movementSpeed)-(movementSpeed/2),y:(Math.random() * movementSpeed)-(movementSpeed/2),z:(Math.random() * movementSpeed)-(movementSpeed/2)});
        }
        var material = new THREE.ParticleBasicMaterial( { size: .03 });
        var particles = new THREE.ParticleSystem( geometry, material );

        this.object = particles;
        this.status = true;

        this.xDir = (Math.random() * movementSpeed)-(movementSpeed/2);
        this.yDir = (Math.random() * movementSpeed)-(movementSpeed/2);
        this.zDir = (Math.random() * movementSpeed)-(movementSpeed/2);

        scene.add( this.object  );

        this.update = function(){
            if (this.status == true){
                var pCount = bufferGeometry.attributes.offset.count;
                while(pCount--) {
                    var particle =  this.object.geometry.vertices[pCount];
                    particle.y += dirs[pCount].y;
                    particle.x += dirs[pCount].x;
                    particle.z += dirs[pCount].z;
                }
                this.object.geometry.verticesNeedUpdate = true;
            }
        }

    }

</script>

</body>
</html>
